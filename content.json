{"meta":{"title":"落花有意","subtitle":"","description":"","author":"lizeyu","url":"https://lizeyu66.github.io","root":"/blog/"},"pages":[{"title":"archives","date":"2021-03-25T08:27:31.000Z","updated":"2021-03-25T08:48:50.719Z","comments":true,"path":"archives/index.html","permalink":"https://lizeyu66.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2021-03-19T02:12:22.000Z","updated":"2021-03-19T02:38:03.214Z","comments":true,"path":"about/index.html","permalink":"https://lizeyu66.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-03-25T07:35:01.000Z","updated":"2021-03-31T02:05:18.492Z","comments":false,"path":"categories/index.html","permalink":"https://lizeyu66.github.io/categories/index.html","excerpt":"","text":""},{"title":"more","date":"2021-03-19T02:12:42.000Z","updated":"2021-03-19T02:12:42.988Z","comments":true,"path":"more/index.html","permalink":"https://lizeyu66.github.io/more/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-19T02:11:56.000Z","updated":"2021-03-31T02:05:22.744Z","comments":true,"path":"tags/index.html","permalink":"https://lizeyu66.github.io/tags/index.html","excerpt":"","text":""},{"title":"test-page","date":"2020-07-31T01:54:06.000Z","updated":"2021-03-17T07:15:39.384Z","comments":true,"path":"test-page/index.html","permalink":"https://lizeyu66.github.io/test-page/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-29T09:16:46.723Z","updated":"2021-03-29T09:16:46.723Z","comments":true,"path":"404/index.html","permalink":"https://lizeyu66.github.io/404/index.html","excerpt":"","text":"var QZONE = window.QZONE || {}; function imagezoom(imgobj, box_w, box_h) { var src_w = imgobj.width; var src_h = imgobj.height; var r1 = src_w / src_h, r2 = box_w / box_h; var dst_w, dst_h; if (r1 > r2) { dst_w = box_w; dst_h = Math.round(dst_w / src_w * src_h); } else { if (r1 < r2) { dst_h = box_h; dst_w = Math.round(dst_h / src_h * src_w); } else { dst_w = box_w; dst_h = box_h; } } imgobj.style.marginLeft = (box_w - dst_w) / 2 + \"px\"; imgobj.style.marginTop = (box_h - dst_h) / 2 + \"px\"; imgobj.style.width = dst_w + \"px\"; imgobj.style.height = dst_h + \"px\"; imgobj.style.opacity = 1; } (function (_w, _d) { var ha = _d.head || _d.getElementsByTagName(\"head\")[0]; var $scope = {}; var current; var tmnow; var chId; var homePageUrl, homePageName; var scs = document.getElementsByTagName(\"script\"); if (location.href.indexOf(\"fm.qq.com\") > -1 || location.href.indexOf(\"fm.qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u4f01\\u9e45FM\"; homePageUrl = \"http://fm.qq.com\"; } else { if (location.href.indexOf(\"qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u6211\\u7684\\u7a7a\\u95f4\"; homePageUrl = \"http://qzone.qq.com\"; } else { homePageName = \"\\u8fd4\\u56de\\u817e\\u8baf\\u7f51\"; homePageUrl = \"http://www.qq.com\"; } } for (var i = 0; i < scs.length; i++) { if (scs[i].src.indexOf(\"404/search_children.js\") > -1) { if (scs[i].getAttribute(\"homePageUrl\")) { homePageUrl = scs[i].getAttribute(\"homePageUrl\"); } if (scs[i].getAttribute(\"homePageName\")) { homePageName = scs[i].getAttribute(\"homePageName\"); } break; } } $scope.rettext = homePageName; $scope.retlink = homePageUrl; function getData(srcUrl, callback) { var sc = _d.createElement(\"script\"); function orc() { if (sc.readyState === \"loaded\") { setTimeout(function () { callback && callback(); }, 0); } } if (sc.addEventListener) { if (callback) { sc.addEventListener(\"load\", callback, false); } } else { sc.attachEvent(\"onreadystatechange\", orc); } ha && ha.appendChild(sc); sc.src = srcUrl; } function resolveData(d) { var tid, len, ddata = [], tdata; if (\"object\" == typeof d && (d.data && (len = d.data.length))) { for (var i = 0; i < len; i++) { var expire = d.data[i].expire; d.data[i]._id = new Date * Math.random() * Math.random() * 1E7; if (expire && tmnow * 1E3 < Date.parse(expire.replace(/\\s[\\s\\S]*$/, \"\").replace(/\\-/g, \"/\"))) { var _c = d.data[i].city, _p = d.data[i].province; if (_c && city) { if ((\"_\" + _c + \"_\").indexOf(\"_\" + city + \"_\") > -1) { ddata.push(d.data[i]); continue; } } if (_p && province) { if ((\"_\" + _p + \"_\").indexOf(\"_\" + province + \"_\") > -1) { ddata.push(d.data[i]); } } } } tid = Math.floor(Math.random() * (ddata.length || len)); tdata = (ddata.length ? ddata : d.data)[chId = tid]; if (_w.foundjsondata) { tdata.ta = tdata.sex.indexOf(\"\\u5973\") > -1 ? \"\\u5979\" : \"\\u4ed6\"; tdata.name = \"\\u201c7\\u00b718\\u7279\\u5927\\u62d0\\u5356\\u5a74\\u513f\\u6848\\u201d\\u544a\\u7834\\uff0c\\u88ab\\u89e3\\u6551\\u768415\\u540d\\u5b69\\u5b50\\u4e2d\\uff0c2\\u4eba\\u7531\\u4eb2\\u751f\\u7236\\u6bcd\\u9886\\u56de\\uff0c\\u4ecd\\u670913\\u540d\\u5b69\\u5b50\\u672a\\u627e\\u5230\\u4eb2\\u751f\\u7236\\u6bcd\\uff0c\\u88ab\\u5b89\\u7f6e\\u5728\\u60e0\\u5dde\\u5e02\\u793e\\u4f1a\\u798f\\u5229\\u9662\\uff0c\" + tdata.ta + \"\\u662f\\u5176\\u4e2d\\u4e4b\\u4e00\\u3002\"; tdata.url = tdata.url.replace(/#p=(\\d{1,2})/, function (a, n) { return \"#p=\" + (+n + 1); }); return format(tmpl2, tdata); } if (!tdata.ext1) { tdata.ext1 = \"\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5bfb\\u627e\\u5931\\u8e2a\\u5b9d\\u8d1d\"; } return tdata; } } function setTopData(tdata) { current = tdata; $scope.topname = tdata.name; $scope.topgender = tdata.sex; $scope.topbirth = tdata.birth_time; $scope.toplostdate = tdata.lost_time; $scope.toplostplace = tdata.lost_place; $scope.toplostdesc = tdata.child_feature; $scope.toplink = tdata.url; $scope.topimg = tdata.child_pic; $scope.topid = tdata._id; document.body.innerHTML = template(\"body\", $scope); } function init(data) { tmnow = data.tm_now * 1E3; var tdata = resolveData(jsondata); $scope.whichin = 0; jsondata.data.splice(chId, 1); $scope.otherdata = [tdata].concat(jsondata.data.slice(0, 5)); setTopData(tdata); } var timeout; window._Callback = function (d) { clearTimeout(timeout); init(d); }; timeout = setTimeout(function () { _Callback({ tm_now: (new Date).getTime() / 1E3 }); }, 2E3); _w.share = function (target) { var summary = [\"\\u80cc\\u666f\\uff1a\", current.name, \"\\uff0c\\u6027\\u522b\\uff1a\", current.sex, \"\\uff0c\\u51fa\\u751f\\u65f6\\u95f4\\uff1a\", current.birth_time, \"\\uff0c\\u5931\\u8e2a\\u65f6\\u95f4\\uff1a\", current.lost_time, \"\\uff0c\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a\", current.child_feature].join(\"\"); if (summary) { summary = \"#\\u5bfb\\u627e\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d#\" + summary; } var stitle = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8be6\\u60c5\"; var desc = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\"; var encode = encodeURIComponent; var opts = { \"surl\": \"http://qzone.qq.com/gy/404/\" + current.id + \"/lostchild.html\", \"site\": \"QQ\\u7a7a\\u95f4\", \"summary\": summary || \"#\\u5b9d\\u8d1d\\u56de\\u5bb6#\\u817e\\u8baf\\u5fd7\\u613f\\u8005\\u7528\\u6280\\u672f\\u70b9\\u4eae\\u516c\\u76ca\\uff0c\\u8ba9\\u6211\\u4eec\\u4e00\\u8d77\\u5bfb\\u627e\\u8d70\\u5931\\u7684\\u513f\\u7ae5\\u5427\\uff01\", \"stitle\": stitle, \"pics\": current.child_pic, \"desc\": desc, \"origin_url\": current.url }; var surl = opts.surl || \"http://www.qq.com/404/\", summary = opts.summary || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u5185\\u5bb9\", stitle = opts.stitle || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u6807\\u9898\", pics = opts.pics || \"http://qzonestyle.gtimg.cn/qzone_v6/act/img/20120422_qzone_7_years/pop_up/icon-pop-seven-years.png\", site = opts.site || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u94fe\\u63a5\\u7684\\u6587\\u5b57\", desc = opts.desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", origin_url = opts.origin_url || \"http://www.qq.com/404/\"; var shareList = { weibo: { method: function (evt) { var w = \"http://v.t.qq.com/share/share.php\", q = [\"?site=\", encode(surl + \"#via=share_t_weib\"), \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"weibo\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); } }, qzone: { method: function (evt) { var buff = [], ps = { url: surl + \"#via=404-qzoneshare\", desc: desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", summary: summary, title: stitle, pics: pics, site: site }; for (var k in ps) { buff.push(k + \"=\" + encode(ps[k] || \"\")); } var w = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?\" + buff.join(\"&\"), q = [\"#via=share_t_qzone\", \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"qzone\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); } }, sina: { method: function () { var w = \"http://v.t.sina.com.cn/share/share.php\", q = [\"?url=\", encode(surl + \"#via=share_x_weib\"), \"&title=\", encode(summary), \"&source=\", \"&sourceUrl=\", surl, \"&content=utf-8\", \"&pic=\", encode(pics)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"sina\", \"toolbar=0,status=0,resizable=1,width=440,height=430\"); } }, kaixin: { method: function () { var n = \"http://www.kaixin001.com/repaste/bshare.php?rurl=\" + encode(surl + \"#via=share_kaixin\") + \"&rcontent=&rtitle=\" + encode(summary); openit(n, \"kaixin\", \"toolbar=0,status=0,resizable=1,width=600,height=360\"); } }, renren: { method: function () { var n = \"http://www.connect.renren.com/share/sharer?title=\" + encode(summary) + \"&url=\" + encode(surl + \"#via=share_renren\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=510,height=300\"); if (p) { p.focus(); } } }, weixin: { method: function () { var n = \"http://qzone.qq.com/gy/404/page/qrcode.html?url=\" + encode(origin_url + \"#via=share_weixin\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=620,height=430\"); if (p) { p.focus(); } } } }; var openit = function (u, n, p) { function o() { var z; if (!(z = window.open(u, n, p))) { location.href = u; } else { z.focus(); } } o(); }; shareList[target] && shareList[target].method(); }; _w.toThis = function (id) { for (var i = 0; i < $scope.otherdata.length; i++) { if ($scope.otherdata[i]._id == id) { setTopData($scope.otherdata[i]); break; } } return false; }; var meta = document.createElement(\"meta\"); meta.name = \"viewport\"; meta.content = \"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"; ha.appendChild(meta); (function registerStyle() { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = \"https://qzone.qq.com/gy/404/style/404style.css\"; ha.appendChild(link); })(); (function initStat() { var qqDomainNameRE = /\\.qq\\.com$/i, qzoneDomainNameRE = /\\bqzone\\.qq\\.com$/i, qzsDomainNameRE = /\\bqzonestyle\\.gtimg\\.cn$/i; function cb() { var url = location.host; var src = \"\"; if (qzoneDomainNameRE.test(url)) { src = \"new404.qzone\"; } else { if (qqDomainNameRE.test(url)) { src = \"new404.qq\"; } else { if (qzsDomainNameRE.test(url)) { src = \"new404.qzonestyle\"; } else { src = url.replace(\".\", \"_\"); } } } _w.TCISD && (_w.TCISD.pv && _w.TCISD.pv(\"hat.qzone.qq.com\", \"/gy/lostchild/\" + src)); } getData(\"https://qzonestyle.gtimg.cn/ac/qzfl/stat.js\", cb); })(); })(window, document); !function () { function a(a, b) { return (/string|function/.test(typeof b) ? h : g)(a, b); } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a; } function c(a) { return l[a]; } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c); } function e(a, b) { if (m(a)) { for (var c = 0, d = a.length; d > c; c++) { b.call(a, a[c], c, a); } } else { for (c in a) { b.call(a, a[c], c); } } } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\"); e.match(c);) { e = e.replace(c, \"/\"); } return e; } function g(b, c) { var d = a.get(b) || i({ filename: b, name: \"Render Error\", message: \"Template not found\" }); return c ? d(c) : d; } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function () { return new k(c); }; } var d = j[a] = function (c) { try { return new b(c, a) + \"\"; } catch (d) { return i(d)(); } }; return d.prototype = b.prototype = n, d.toString = function () { return b + \"\"; }, d; } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) { c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); } else { for (var d in a) { c += \"\\n\" + a[d] + \"\\n\\n\"; } } return function () { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b; }; } var j = a.cache = {}, k = this.String, l = { \"\": \"&#62;\", '\"': \"&#34;\", \"'\": \"&#39;\", \"&\": \"&#38;\" }, m = Array.isArray || function (a) { return \"[object Array]\" === {}.toString.call(a); }, n = a.utils = { $helpers: {}, $include: function (a, b, c) { return a = f(c, a), g(a, b); }, $string: b, $escape: d, $each: e }, o = a.helpers = n.$helpers; a.get = function (a) { return j[a.replace(/^\\.\\//, \"\")]; }, a.helper = function (a, b) { o[a] = b; }, \"function\" == typeof define ? define(function () { return a; }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function (a) { var b = this, c = (b.$helpers, b.$escape), d = a.retlink, e = a.rettext, f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404\\uff0c\\u60a8\\u8bbf\\u95ee\\u7684\\u9875\\u9762\\u627e\\u4e0d\\u56de\\u6765\\u4e86\\uff0c\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5e2e\\u4ed6\\u4eec\\u56de\\u5bb6\\uff01 ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') \\u51fa\\u751f\\u65e5\\u671f\\uff1a', r += c(j), r += ' \\u5931\\u8e2a\\u65f6\\u95f4\\uff1a', r += c(l), r += ' \\u5931\\u8e2a\\u5730\\u70b9\\uff1a', r += c(m), r += ' \\u5931\\u8e2a\\u4eba\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a', r += c(n), r += ' \\u67e5\\u770b\\u8be6\\u60c5 \\u5206\\u4eab \\u817e\\u8baf\\u5fae\\u535a QQ\\u7a7a\\u95f4 \\u65b0\\u6d6a\\u5fae\\u535a \\u5fae\\u4fe1 ', p(q, function (a) { r += ' '; }), r += \" \", new k(r); }); }();"}],"posts":[{"title":"webInterview","slug":"webInterview","date":"2021-03-31T08:48:23.000Z","updated":"2021-04-06T05:16:54.696Z","comments":true,"path":"2021/03/31/webInterview/","link":"","permalink":"https://lizeyu66.github.io/2021/03/31/webInterview/","excerpt":"","text":"JavaScript js数据类型以及如何判断数据类型 基本数据类型： string number boolean null undefined symbol 引用数据类型：object 判断数据类型常用的是typeof、instanceof(可以准确的判断对象的类型) 作用域和作用域链 含义：定义变量的区域，有一套访问变量的规则，根据这规则来管理浏览器引擎如何在当前作用域和嵌套作用域根据变量进行变量查找 作用域的分类：全局作用域、函数作用域、块作用域 作用域链： 当js使用一个变量的时候，会先在当前作用域寻找该变量，如何当前作用域找不到，则回到上一级作用域去寻找，以此类推知道找到该变量 this 在全局范围内, this指向的是window函数中this指的是调用他的那个对象（箭头函数特殊）构造函数中，this指向的是new出来的新对象call, apply中，this被绑定在指定的对象箭头函数中，this指向的是函数定义时作用域的this 原型与原型链 4.1 构造函数 ES的构造函数其实就是能创建对象的函数,使用new调用的函数是构造函数，直接调用的则是普通函数 12345678function Person(name, age, job) &#123; this.name &#x3D; name; this.age &#x3D; age; this.job &#x3D; job; this.sayName &#x3D; function() &#123; alert(this.name) &#125; &#125;var person1 &#x3D; new Person(&#39;Zaxlct&#39;, 28, &#39;Software Engineer&#39;);var person2 &#x3D; new Person(&#39;Mick&#39;, 23, &#39;Doctor&#39;); person1和person2都是person的实例，这两个实例都有一个constructor(即构造函数)，该属性指向Person,换句话说就是实例的构造函数属性指向构造函数 其实person1和person2也是Object的实例，因为所有自定义对象都是继承于Object constructor其实是用来标识对象类型的，但实际上一般使用instanceof来确定对象类型，所以如下表达式成立 1234console.log(person1.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;trueconsole.log(person2.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;trueconsole.log(person1 instanceof Object); &#x2F;&#x2F; trueconsole.log(person1 instanceof Person) &#x2F;&#x2F; true 4.2 原型对象 js中每定义一个对象（函数也是对象）时，对象中都会包含一些预先定义的属性，当定义函数对象时，就会被包含prototype属性，该属性指向函数的原型对象 Object.getPrototypeOf() 可以获得传入对象的原型对象 123456789101112131415function Person() &#123;&#125;Person.prototype.name &#x3D; &#39;Zaxlct&#39;;Person.prototype.age &#x3D; 28;Person.prototype.job &#x3D; &#39;Software Engineer&#39;;Person.prototype.sayName &#x3D; function() &#123; alert(this.name);&#125; var person1 &#x3D; new Person();person1.sayName(); &#x2F;&#x2F; &#39;Zaxlct&#39;var person2 &#x3D; new Person();person2.sayName(); &#x2F;&#x2F; &#39;Zaxlct&#39;console.log(person1.sayName &#x3D;&#x3D; person2.sayName); &#x2F;&#x2F;true 每个对象都有_proto_属性，只有函数对象才有prototype属性， 但是Function.prototype除外 那什么是原型对象呢？看如下代码(Person.prototype指向原型对象) 12345678Person.prototype &#x3D; &#123; name: &#39;Zaxlct&#39;, age: 28, job: &#39;Software Engineer&#39;, sayName: function() &#123; alert(this.name); &#125;&#125; 原型对象其实就是一个普通对象，其实就是Person.prototype,甚至可以给其赋值 var a = Person.prototype,上述代码中给a添加四个属性name、age、job、sayName,但其实还有一个默认属性construcor 默认情况下，所有原型对象都会有一个构造函数（constructor）属性,这个属性指向prototype所在的函数（Person），并且这个元素是个指针，即 Person.prototype.constructor == Person 从之前的结论可以知道实例的构造函数指向构造函数， 即 person1.constructor == Person 换句话说，Person.prototype也是Person的实例(有待考证)，即原型对象是构造函数的一个实例 实例只有指向原型的指针，没有指向构造函数的指针 重写构造函数的原型之后，在创建的实例才会引用新的原型 4.3 protojs在创建对象的时候都有一个叫做proto的内置属性，用于指向创建他的构造函数的原型对象 person1.proto== Person.prototype 4.4 构造器我们可以使用 var obj = {}来创建一个对象，等同于var obj = new Object(),所以 obj.constructor == Objectobj.proto == Object.prototype 同理，创建对象的构造器不只是Object,也可以是Array,Date,Function等这些构造器都是函数对象 1234567891011var b &#x3D; new Array();b.constructor &#x3D;&#x3D;&#x3D; Array;b.__proto__ &#x3D;&#x3D;&#x3D; Array.prototype;var c &#x3D; new Date(); c.constructor &#x3D;&#x3D;&#x3D; Date;c.__proto__ &#x3D;&#x3D;&#x3D; Date.prototype;var d &#x3D; new Function();d.constructor &#x3D;&#x3D;&#x3D; Function;d.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype; 所有函数对象的_proto_都指向Function.prototype，它是一个空函数（Empty function）所有对象的_proto_都指向其构造器的prototype4.5 原型链 person1.proto = Person.prototype person1的_proto_等于person1构造函数的prototypeperson1.constructor == Person Person.proto = Function.ptototype Person._proto_等于Person.constructor的prototype，Person.constructor = Function Person.prototype.proto = Object.prototype Person.prototype是一个普通对象，即Object.prototype Object.proto = Function.prototype object的构造函数是Function Object.prototype.proto = null Object.prototype 对象也有proto属性,为null,因为他处于原型链的顶端 4.6 函数对象所有函数对象的_proto_（即所有的构造器）都指向Function.prototype，换句话说所有函数对象的构造函数都是Function所有构造器都继承Function.prototype的属性及方法 Function.prototype是唯一一个 typeof Function.prototype == Function的prototype其他构造器的prototype都是object普通对象.proto = Function.ptototypeFunction.prototype.proto === Object.prototypeObject.prototype.proto === null 4.7 原型链案例 12345678910111213141516function Person() &#123;&#125;var person1 &#x3D; new Person()person1.__proto__ &#x3D;&#x3D;&#x3D; Person.prototypePerson.__proto__ &#x3D;&#x3D; Function.prototype &#x2F;&#x2F; 所有函数对象的__proto__都指向Function.prototypePerson.prototype._proto_ &#x3D;&#x3D; Object.prototypeFunction.__proto__ &#x3D;&#x3D; Function.prototype &#x2F;&#x2F; Function也属于函数对象Function.prototype.__proto__ &#x3D;&#x3D; Object.prototypeObject.prototype.__proto__&#x3D;&#x3D; nullvar num &#x3D; new Array()num.__proto__ &#x3D;&#x3D; Array.prototypeArray.prototype.__proto__ &#x3D;&#x3D; Object.prototypeObject.prototype.__proto__ &#x3D;&#x3D; nullArray.__proto__ &#x3D; Function.prototype 4.8 hasOwnProperty、in、for in的用法 hasOwnProperty() 方法用于确定某个属性是否存在于实例中，存在则返回truein 可以确定某属性是否存在于原型或实例上，只要存在就返回true因此只要hasOwnProperty()返回false, in 返回true,就说明该属性是原型属性在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性获得对象上所有可枚举的实例属性，使用Object.keys(obj)列出所有实例属性（包含不可枚举的）可使用Object.getOwnPropertyNames() 4.9 ES2017新增Object.values()和Object.entries() Object.value()返回对象值的数组Object.entries()返回对象键值对的数组 12345678const o &#x3D; &#123; foo: &#39;bar&#39; , baz: 1, qux: &#123;&#125;&#125;;console.log(Object.values(o)); &#x2F;&#x2F; [&quot;bar&quot;, 1, &#123;&#125;]console.log(Object.entries((o))); &#x2F;&#x2F; [[&quot;foo&quot;,&quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]] 4.10 原型链的问题 原型中包含的引用值会在所有实例间共享 1234567891011function SuperType() &#123; this.colors &#x3D; [&quot;red&quot; , &quot;blue&quot; , &quot;green&quot;];&#125;function SubType() &#123;&#125;&#x2F;&#x2F; 继承SuperTypeSubType.prototype &#x3D; new SuperType();let instance1 &#x3D; new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); &#x2F;&#x2F; &quot;red,blue,green,black&quot;let instance2 &#x3D; new SubType();console.log(instance2.colors); &#x2F;&#x2F; &quot;red,blue,green,black&quot; 子类型在实例化时不能给父类型的构造函数传参 4.11 盗用构造函数为解决原型包含引用值导致的继承问题，“盗用构造函数”流行了起来，也叫“对象伪装”，“经典继承”基本思路：在子类构造函数中通过call/apply调用父类构造函数 123456789101112function SuperType() &#123; this.colors &#x3D; [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;function SubType() &#123; &#x2F;&#x2F; 继承SuperType SuperType.call(this);&#125;let instance1 &#x3D; new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); &#x2F;&#x2F; &quot;red,blue,green,black&quot;let instance2 &#x3D; new SubType();console.log(instance2.colors); &#x2F;&#x2F; &quot;red,blue,green&quot; 优点：在子类构造函数中向父类构造函数传参存在的问题：必须在构造函数中定义方法，因此函数不能重用","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://lizeyu66.github.io/tags/WEB/"}]},{"title":"js事件执行机制（EventLoop）","slug":"jsEventLoop","date":"2021-01-23T09:59:08.000Z","updated":"2021-03-26T02:36:22.339Z","comments":true,"path":"2021/01/23/jsEventLoop/","link":"","permalink":"https://lizeyu66.github.io/2021/01/23/jsEventLoop/","excerpt":"","text":"概述javascript是一门单线程语言，js任务是一个一个顺序执行，分为同步任务和异步任务，同步任务会进入主线程，异步任务会进入Event Table（事件表），当时间表中的异步任务完成后就会在Event Queue（事件队列）中注册回调函数，主线程任务全部完成后，才会执行Event Queue中的回调，js解析器会不断重复检查主线程执行栈是否为空，然后重复第3步，这就是Event Loop（事件循环） 简单来说就是： 先同步后异步 遇到new Promise先执行 先微任务后宏任务 宏任务与微任务macro-task(宏任务)：包括整体代码script，setTimeout，setInterval, setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。micro-task(微任务)：Promise.then，process.nextTick 总结 一般的JavaScript代码（同步）的属于宏任务，定时器相关的异步代码，包括setTimeOut、setInterval等也属于宏任务，promise.then、 process.nextTick属于微任务； 同步的代码会按照执行顺序顺序执行，遇到异步代码的时候，属于宏任务的放到宏队列，微任务放到微队列，其中promise需要resolve或者reject才会执行then或者catch里面的内容，其他的放到队列的属于回调函数的内容。 执行顺序是宏任务-微任务-宏任务……，因为整个脚本就是一个宏任务，所以当里面宏任务和微任务同时放入队列，会先执行玩微任务再执行宏任务；前提是代码执行完毕，如果存在嵌套关系，则会先执行完该任务再执行下一个任务，如果问题复杂建议通过画图来理清楚 process.nextTick只能在node环境下运行 async await 与 Promise async声明的必须是一个function，并且必须紧跟着function async function process() {} await必须在async声明的函数内部使用，必须是直系 async生命的函数本质上是一个Promise 12345678910111213141516171819&#x2F;&#x2F; 以下三个函数表达的意思一致const demo &#x3D;(async function() &#123; return &#39;我是promise&#39; &#125;) () const demo &#x3D; (async function() &#123; return Promise.resolve(&#39;我是promise&#39;) &#125;)()const demo &#x3D;（async function() &#123; return new Promise((resolve,reject) &#x3D;&gt; &#123; resolve(&#39;我是promise&#39;) &#125;)&#125;)()&#x2F;&#x2F; 获取返回值的方法demo.then(res &#x3D;&gt; &#123; console.log(res) &#125;) await的本质是提供等同于“同步效果”的等待异步返回能力的语法糖，实质上就是返回一个Promise await意为等一会，只要await生命的函数还没有返回，下面的内容就不会被执行，准确的说是用await声明的Promise异步返回，必须等待到有返回值之后，才继续执行以后的代码 async/await的错误处理 async/await的终止程序（中断） Promise本身是无法终止的，只是一个状态机，包含三种状态pending（挂起）、resolve（成功）、reject（拒绝），一旦发出请求必须结束，无法取消，想要中断的时候直接return 一个值即可，return之后的操作将都会停止","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lizeyu66.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://lizeyu66.github.io/tags/javascript/"}]},{"title":"chrome跨域请求携带cookie丢失问题(80版本之后)","slug":"chromeProblem","date":"2020-04-30T06:04:53.000Z","updated":"2021-03-30T06:21:39.878Z","comments":true,"path":"2020/04/30/chromeProblem/","link":"","permalink":"https://lizeyu66.github.io/2020/04/30/chromeProblem/","excerpt":"","text":"针对测试环境的解决方法 打开chrome 输入 chrome://flags/ 搜索 SameSite by default cookies 以及 Cookies without SameSite must be secure 将两项都修改为Disabled 点击relaunch重新加载 针对正式 拒绝使用跨域的cookie","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/tags/web/"}]},{"title":"indexedDB使用方法","slug":"indexedDB","date":"2020-04-06T09:58:06.000Z","updated":"2021-03-26T02:36:31.474Z","comments":true,"path":"2020/04/06/indexedDB/","link":"","permalink":"https://lizeyu66.github.io/2020/04/06/indexedDB/","excerpt":"","text":"使用IndexedDB的原因提到为什么要用IndexedDB就不得不提到我们经常用的缓存API localStorage和sessionStorage，这两个缓存API能满足我们开发时的绝大多数需求，简单的键值存储，但是它们有它们的限制： 存储空间限制，只有5M只能存储字符串，存储对象类型的数据要用JSON.stringify和parse两个方法转换存储的字段一多就很难管理，存储的字段也无法产生关联IndexedDB的存储空间是没有限制，但是不同浏览器可能会对IndexedDB中单个库的大小进行一定的限制，IndexedDB本质上还是一个数据库，可以存储大量结构化数据（包括文件/blobs）, 同时IndexedDB API通过索引的方式实现了数据的高性能搜索 打开数据库/新建数据库indexedDB.open(dbName, version) 参数1：数据库名称（如果数据库不存在，则会新建） 参数2: 数据库版本（若省略，则默认为当前版本，新建数据库时，默认为1） 12345678910111213141516let routerDBRequest &#x3D; window.indexedDB.open([dataBaseName])&lt;!-- error 表示数据库打开失败 --&gt;routerDBRequest.onerror &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;打开失败&#39;)&#125;&lt;!-- success 表示数据库打开成功 --&gt;routerDBRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;打开成功&#39;)&#125;&lt;!-- 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded --&gt;request.onupgradeneeded &#x3D; function (event) &#123; db &#x3D; event.target.result;&#125; 读取数据objectStore.get(primaryKey) 参数：主键的值 123456789101112131415let routerDBRequest &#x3D; window.indexedDB.open(&#39;dataAnalysis&#39;)routerDBRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123; db &#x3D; event.target.result let trans &#x3D; db.transaction([&#39;allRouteData&#39;]) let objectStores &#x3D; trans.objectStore(&#39;allRouteData&#39;) let request &#x3D; objectStores.get(1) request.onsuccess &#x3D; (event) &#x3D;&gt; &#123; if(event.target.result) &#123; &#125; const newRoute &#x3D; [] newRoute.push(event.target.result) &#125;&#125; 批量读取数据12345678910111213objectStores.openCursor().onsuccess &#x3D; (event) &#x3D;&gt; &#123; let res &#x3D; event.target.result if(res) &#123; let val &#x3D; res.value newRoute.push(val) store.dispatch(&#39;dealRouter&#x2F;SaveAllRouter&#39;, newRoute) router.push(&#123; path: newRoute[0].path &#125;) res.continue() &#125; else &#123; console.log(&#39;完成索引&#39;) &#125;&#125; 修改数据objectStore.put(item) 参数：一列数据 123456789101112let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;)const newRoute &#x3D; []objectStores.put(&#123;id: 1, name: &#39;首页&#39;, component: &#39;Layout&#39;, path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;dashboard&#39;, meta:&#39;&#123;&quot;title&quot;:&quot;首页&quot;&#125;&#39;, children: [&#123; name: &#39;首页&#39;, path: &#39;dashboard&#39;, component: &#39;Dashboard&#39;, id: 2, meta:&#39;&#123;&quot;title&quot;:&quot;首页&quot;&#125;&#39;&#125;]&#125;) 删除数据objectStore.del(num) 参数：删除的条数 12345let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;).del(1)request.onsuccess &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;数据删除成功&#39;)&#125; 使用索引索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。 12objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;) 完整测试案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788let routerDBRequest &#x3D; window.indexedDB.open(&#39;dataAnalysis&#39;)&lt;!-- error 表示数据库打开失败 --&gt;routerDBRequest.onerror &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;打开失败&#39;) console.log(event)&#125;&lt;!-- success 表示数据库打开成功 --&gt;routerDBRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;打开成功&#39;) &lt;!-- 读取单条数据 --&gt; db &#x3D; event.target.result let trans &#x3D; db.transaction([&#39;allRouteData&#39;]) let objectStores &#x3D; trans.objectStore(&#39;allRouteData&#39;) let request &#x3D; objectStores.get(1) &#x2F;&#x2F; get参数为主键的值 request.onsuccess &#x3D; (event) &#x3D;&gt; &#123; const newRoute &#x3D; [] newRoute.push(event.target.result) store.dispatch(&#39;dealRouter&#x2F;SaveAllRouter&#39;, newRoute) router.push(&#123; path: newRoute[0].path &#125;) &#125; &lt;!-- 批量读取数据 --&gt; objectStores.openCursor().onsuccess &#x3D; (event) &#x3D;&gt; &#123; let res &#x3D; event.target.result if(res) &#123; let val &#x3D; res.value newRoute.push(val) store.dispatch(&#39;dealRouter&#x2F;SaveAllRouter&#39;, newRoute) router.push(&#123; path: newRoute[0].path &#125;) res.continue() &#125; else &#123; console.log(&#39;完成索引&#39;) &#125; &#125; &lt;!-- 修改数据 --&gt; let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;) const newRoute &#x3D; [] objectStores.put(&#123;id: 1, name: &#39;首页&#39;, component: &#39;Layout&#39;, path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;dashboard&#39;, meta:&#39;&#123;&quot;title&quot;:&quot;首页&quot;&#125;&#39;, children: [&#123; name: &#39;首页&#39;, path: &#39;dashboard&#39;, component: &#39;Dashboard&#39;, id: 2, meta:&#39;&#123;&quot;title&quot;:&quot;首页&quot;&#125;&#39; &#125;]&#125;) &lt;!-- 删除数据 --&gt; let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;).del(1) request.onsuccess &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;数据删除成功&#39;) &#125;&#125;&#125;&lt;!-- upgradeneeded 数据库升级事件（指定版本大于数据库实际版本时触发） --&gt;routerDBRequest.onupgradeneeded &#x3D; (event) &#x3D;&gt; &#123; let db &#x3D; event.target.result &lt;!-- 创建数据仓库&#x2F;新建表 --&gt; &lt;!-- allRouteData为表名,keyPath为主键,使用autoIncrement可以自动生成主键 --&gt; if(!db.objectStoreNames.contains(&quot;allRouteData&quot;)) &#123; let allRoute &#x3D; this.db.createObjectStore(&quot;allRouteData&quot;, &#123; keyPath: &#39;id&#39;&#125;) &lt;!-- IDBObject.createIndex()是新建索引的方法， 三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值） --&gt; allRoute.createIndex(&#39;id&#39;, &#39;id&#39;, &#123; unique: true &#125;) allRoute.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;) allRoute.createIndex(&#39;path&#39;, &#39;path&#39;, &#123; unique: false &#125;) allRoute.createIndex(&#39;component&#39;, &#39;component&#39;, &#123; unique: false &#125;) allRoute.createIndex(&#39;hiddenInMenu&#39;, &#39;hiddenInMenu&#39;, &#123; unique: false&#125;) allRoute.createIndex(&#39;redirect&#39;, &#39;redirect&#39;, &#123;unique: false&#125;) allRoute.createIndex(&#39;meta&#39;, &#39;meta&#39;, &#123; unique: false&#125;) &#125; &lt;!-- 写入数据 --&gt; var objectStore &#x3D; transaction.objectStore(&quot;allRouteData&quot;) let addReq &#x3D; objectStore.add($&#123;data&#125;) addReq.onsuccess &#x3D; (event)&#x3D;&gt; &#123; console.log(&#39;数据写入成功&#39;) &#125; addReq.onerror &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;数据写入失败&#39;) &#125; &lt;!-- 利用索引检索数据 --&gt; let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;) let index &#x3D; objectStores.index(&quot;name&quot;) index.get(&#39;首页&#39;).onsuccess &#x3D; (event)&#x3D;&gt; &#123; console.log(event.target.result) &#125;","categories":[{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/tags/web/"}]},{"title":"使用picGo存储图片","slug":"picGoc","date":"2020-03-25T03:05:31.000Z","updated":"2021-03-26T02:36:13.006Z","comments":true,"path":"2020/03/25/picGoc/","link":"","permalink":"https://lizeyu66.github.io/2020/03/25/picGoc/","excerpt":"","text":"介绍作为一个前端党，没有自己的服务器，所以在开发自己的博客的时候，存放图片是个棘手的问题。一开始我是使用github直接存储的，后来发现这样访问起来会很慢，后来发现了picGo这个工具，可以快速的上传图片到github，并且能获取到图片的url, 可在别的地方使用。PicGo是一个用于快速上传图片并获取图片 URL 链接的工具，配置较为简单，支持多种图床。 PicGo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 &amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM. MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 安装与使用点击此处可下载官方版 windows用户可下载最新版的exe文件 macOS 用户请下载最新版本的 dmg 文件 Linux 用户请下载 AppImage 文件 安装完成打开软件是如下界面 使用github图床 picGo支持的图床有很多，我使用的是github图床，配置较简单，比直接在github中存储图片更加友好 首先得注册一个github账号，注册方法应该不用多言，相信大家都已经有了 新建一个仓库，并且记下仓库名 最好是设置为公共仓库，私有仓库的话可能在picGo中会出现无法预览已上传图片的问题 生成一个token, 可以使picGo操作git 访问 https://github.com/settings/tokens进入到获取token页面 然后点击 Generate new token 把repo的勾打上即可。然后翻到页面最底部，点击Generate token的绿色按钮生成token。 值得注意的是：这个token只会生成一次，所以需要保存下来以供之后使用 配置picGo 注意：仓库名的格式是 ‘用户名/仓库名’, 分支名写main就可以，master是不生效的，token就是刚才保存的token, 存储路径可设可不设，自定义域名可以设置加速上传路径，路径之后拼接 ‘用户名/仓库名@分支’即可，最后就可以点击确定以生效，点击设为默认图床来确保上传的图床是GitHub。 配置完成之后就可以上传图片了，上传成功之后，仓库里就会出现新上传的图片了","categories":[{"name":"image","slug":"image","permalink":"https://lizeyu66.github.io/categories/image/"}],"tags":[{"name":"image","slug":"image","permalink":"https://lizeyu66.github.io/tags/image/"}]},{"title":"解决hexo分类和标签页面空白页的问题","slug":"hexoNotice","date":"2020-02-12T07:54:56.000Z","updated":"2021-03-26T07:53:13.016Z","comments":true,"path":"2020/02/12/hexoNotice/","link":"","permalink":"https://lizeyu66.github.io/2020/02/12/hexoNotice/","excerpt":"","text":"使用hexo搭建博客的过程中，分类和标签页面一直是空白的问题困扰了我很久，右侧的标签栏中能够正常显示分类和标签，但是跳转到详情页面却是空白的，后来终于找到了解决方案。 首先要创建分类页面 hexo new page categories执行此命令后，会在source文件夹下生成categories文件夹，里面包含index.md文件 文章页面中设置categories: 分类名，即可将文章归为某分类下 编辑categories文件夹下的index.md文件 代码很简单，值得注意的是layout的值与当前所用的主题中layout文件夹中的文件命名须一致，一开始我写的是 layout: categories, 后来发现我使用的主题layout文件夹下是 category.ejs，而不是 categories.ejs，所以分类无法显示，当layout的值修改为category之后，分类页面便可以显示正常。 12345678---title: categoriesdate: 2021-03-25 15:35:01type: categorieslayout: categorycomments: false--- 在主题文件夹中找到_config.yml文件，搜索menu字段，将分类的url设置为 ‘/categories’, 如： 标签页面与分类页面同理","categories":[{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lizeyu66.github.io/tags/hexo/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"https://lizeyu66.github.io/categories/javascript/"},{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/categories/web/"},{"name":"image","slug":"image","permalink":"https://lizeyu66.github.io/categories/image/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://lizeyu66.github.io/tags/WEB/"},{"name":"javascript","slug":"javascript","permalink":"https://lizeyu66.github.io/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/tags/web/"},{"name":"image","slug":"image","permalink":"https://lizeyu66.github.io/tags/image/"},{"name":"hexo","slug":"hexo","permalink":"https://lizeyu66.github.io/tags/hexo/"}]}