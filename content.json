{"meta":{"title":"落花有意","subtitle":"","description":"","author":"lizeyu","url":"https://lizeyu66.github.io","root":"/lizeyu66.github.io/"},"pages":[{"title":"about","date":"2021-03-19T02:12:22.000Z","updated":"2021-03-19T02:38:03.214Z","comments":true,"path":"about/index.html","permalink":"https://lizeyu66.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-03-25T07:35:01.000Z","updated":"2021-03-25T07:53:48.438Z","comments":false,"path":"categories/index.html","permalink":"https://lizeyu66.github.io/categories/index.html","excerpt":"","text":""},{"title":"more","date":"2021-03-19T02:12:42.000Z","updated":"2021-03-19T02:12:42.988Z","comments":true,"path":"more/index.html","permalink":"https://lizeyu66.github.io/more/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-19T02:11:56.000Z","updated":"2021-03-25T07:54:08.470Z","comments":true,"path":"tags/index.html","permalink":"https://lizeyu66.github.io/tags/index.html","excerpt":"","text":""},{"title":"test-page","date":"2020-07-31T01:54:06.000Z","updated":"2021-03-17T07:15:39.384Z","comments":true,"path":"test-page/index.html","permalink":"https://lizeyu66.github.io/test-page/index.html","excerpt":"","text":""},{"title":"timeline","date":"2021-03-25T07:27:33.000Z","updated":"2021-03-25T07:27:33.921Z","comments":true,"path":"timeline/index.html","permalink":"https://lizeyu66.github.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"解决hexo分类和标签页面空白页的问题","slug":"hexoNotice","date":"2021-03-25T07:54:56.000Z","updated":"2021-03-25T08:20:59.780Z","comments":true,"path":"2021/03/25/hexoNotice/","link":"","permalink":"https://lizeyu66.github.io/2021/03/25/hexoNotice/","excerpt":"","text":"使用hexo搭建博客的过程中，分类和标签页面一直是空白的问题困扰了我很久，右侧的标签栏中能够正常显示分类和标签，但是跳转到详情页面却是空白的，后来终于找到了解决方案。 首先要创建分类页面 hexo new page categories执行此命令后，会在source文件夹下生成categories文件夹，里面包含index.md文件 文章页面中设置categories: 分类名，即可将文章归为某分类下 编辑categories文件夹下的index.md文件 代码很简单，值得注意的是layout的值与当前所用的主题中layout文件夹中的文件命名须一致，一开始我写的是 layout: categories, 后来发现我使用的主题layout文件夹下是 category.ejs，而不是 categories.ejs，所以分类无法显示，当layout的值修改为category之后，分类页面便可以显示正常。 12345678---title: categoriesdate: 2021-03-25 15:35:01type: categorieslayout: categorycomments: false--- 在主题文件夹中找到_config.yml文件，搜索menu字段，将分类的url设置为 ‘/categories’, 如： 标签页面与分类页面同理","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lizeyu66.github.io/tags/hexo/"}]},{"title":"使用picGo存储图片","slug":"picGoc","date":"2021-03-25T03:05:31.000Z","updated":"2021-03-25T06:01:29.883Z","comments":true,"path":"2021/03/25/picGoc/","link":"","permalink":"https://lizeyu66.github.io/2021/03/25/picGoc/","excerpt":"","text":"介绍作为一个前端党，没有自己的服务器，所以在开发自己的博客的时候，存放图片是个棘手的问题。一开始我是使用github直接存储的，后来发现这样访问起来会很慢，后来发现了picGo这个工具，可以快速的上传图片到github，并且能获取到图片的url, 可在别的地方使用。PicGo是一个用于快速上传图片并获取图片 URL 链接的工具，配置较为简单，支持多种图床。 PicGo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 &amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM. MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 安装与使用点击此处可下载官方版 windows用户可下载最新版的exe文件 macOS 用户请下载最新版本的 dmg 文件 Linux 用户请下载 AppImage 文件 安装完成打开软件是如下界面 使用github图床 picGo支持的图床有很多，我使用的是github图床，配置较简单，比直接在github中存储图片更加友好 首先得注册一个github账号，注册方法应该不用多言，相信大家都已经有了 新建一个仓库，并且记下仓库名 最好是设置为公共仓库，私有仓库的话可能在picGo中会出现无法预览已上传图片的问题 生成一个token, 可以使picGo操作git 访问 https://github.com/settings/tokens进入到获取token页面 然后点击 Generate new token 把repo的勾打上即可。然后翻到页面最底部，点击Generate token的绿色按钮生成token。 值得注意的是：这个token只会生成一次，所以需要保存下来以供之后使用 配置picGo 注意：仓库名的格式是 ‘用户名/仓库名’, 分支名写main就可以，master是不生效的，token就是刚才保存的token, 存储路径可设可不设，自定义域名可以设置加速上传路径，路径之后拼接 ‘用户名/仓库名@分支’即可，最后就可以点击确定以生效，点击设为默认图床来确保上传的图床是GitHub。 配置完成之后就可以上传图片了，上传成功之后，仓库里就会出现新上传的图片了","categories":[{"name":"image","slug":"image","permalink":"https://lizeyu66.github.io/categories/image/"}],"tags":[{"name":"image","slug":"image","permalink":"https://lizeyu66.github.io/tags/image/"}]},{"title":"js事件执行机制（EventLoop）","slug":"jsEventLoop","date":"2021-03-23T09:59:08.000Z","updated":"2021-03-25T02:28:32.710Z","comments":true,"path":"2021/03/23/jsEventLoop/","link":"","permalink":"https://lizeyu66.github.io/2021/03/23/jsEventLoop/","excerpt":"","text":"概述javascript是一门单线程语言，js任务是一个一个顺序执行，分为同步任务和异步任务，同步任务会进入主线程，异步任务会进入Event Table（事件表），当时间表中的异步任务完成后就会在Event Queue（事件队列）中注册回调函数，主线程任务全部完成后，才会执行Event Queue中的回调，js解析器会不断重复检查主线程执行栈是否为空，然后重复第3步，这就是Event Loop（事件循环） 简单来说就是： 先同步后异步 遇到new Promise先执行 先微任务后宏任务 宏任务与微任务macro-task(宏任务)：包括整体代码script，setTimeout，setInterval, setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。micro-task(微任务)：Promise.then，process.nextTick 总结 一般的JavaScript代码（同步）的属于宏任务，定时器相关的异步代码，包括setTimeOut、setInterval等也属于宏任务，promise.then、 process.nextTick属于微任务； 同步的代码会按照执行顺序顺序执行，遇到异步代码的时候，属于宏任务的放到宏队列，微任务放到微队列，其中promise需要resolve或者reject才会执行then或者catch里面的内容，其他的放到队列的属于回调函数的内容。 执行顺序是宏任务-微任务-宏任务……，因为整个脚本就是一个宏任务，所以当里面宏任务和微任务同时放入队列，会先执行玩微任务再执行宏任务；前提是代码执行完毕，如果存在嵌套关系，则会先执行完该任务再执行下一个任务，如果问题复杂建议通过画图来理清楚 process.nextTick只能在node环境下运行 async await 与 Promise async声明的必须是一个function，并且必须紧跟着function async function process() {} await必须在async声明的函数内部使用，必须是直系 async生命的函数本质上是一个Promise 12345678910111213141516171819&#x2F;&#x2F; 以下三个函数表达的意思一致const demo &#x3D;(async function() &#123; return &#39;我是promise&#39; &#125;) () const demo &#x3D; (async function() &#123; return Promise.resolve(&#39;我是promise&#39;) &#125;)()const demo &#x3D;（async function() &#123; return new Promise((resolve,reject) &#x3D;&gt; &#123; resolve(&#39;我是promise&#39;) &#125;)&#125;)()&#x2F;&#x2F; 获取返回值的方法demo.then(res &#x3D;&gt; &#123; console.log(res) &#125;) await的本质是提供等同于“同步效果”的等待异步返回能力的语法糖，实质上就是返回一个Promise await意为等一会，只要await生命的函数还没有返回，下面的内容就不会被执行，准确的说是用await声明的Promise异步返回，必须等待到有返回值之后，才继续执行以后的代码 async/await的错误处理 async/await的终止程序（中断） Promise本身是无法终止的，只是一个状态机，包含三种状态pending（挂起）、resolve（成功）、reject（拒绝），一旦发出请求必须结束，无法取消，想要中断的时候直接return 一个值即可，return之后的操作将都会停止","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lizeyu66.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://lizeyu66.github.io/tags/javascript/"}]},{"title":"indexedDB使用方法","slug":"indexedDB","date":"2020-03-23T09:58:06.000Z","updated":"2021-03-25T07:47:50.828Z","comments":true,"path":"2020/03/23/indexedDB/","link":"","permalink":"https://lizeyu66.github.io/2020/03/23/indexedDB/","excerpt":"","text":"使用IndexedDB的原因提到为什么要用IndexedDB就不得不提到我们经常用的缓存API localStorage和sessionStorage，这两个缓存API能满足我们开发时的绝大多数需求，简单的键值存储，但是它们有它们的限制： 存储空间限制，只有5M只能存储字符串，存储对象类型的数据要用JSON.stringify和parse两个方法转换存储的字段一多就很难管理，存储的字段也无法产生关联IndexedDB的存储空间是没有限制，但是不同浏览器可能会对IndexedDB中单个库的大小进行一定的限制，IndexedDB本质上还是一个数据库，可以存储大量结构化数据（包括文件/blobs）, 同时IndexedDB API通过索引的方式实现了数据的高性能搜索 打开数据库/新建数据库indexedDB.open(dbName, version) 参数1：数据库名称（如果数据库不存在，则会新建） 参数2: 数据库版本（若省略，则默认为当前版本，新建数据库时，默认为1） 12345678910111213141516let routerDBRequest &#x3D; window.indexedDB.open([dataBaseName])&lt;!-- error 表示数据库打开失败 --&gt;routerDBRequest.onerror &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;打开失败&#39;)&#125;&lt;!-- success 表示数据库打开成功 --&gt;routerDBRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;打开成功&#39;)&#125;&lt;!-- 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded --&gt;request.onupgradeneeded &#x3D; function (event) &#123; db &#x3D; event.target.result;&#125; 读取数据objectStore.get(primaryKey) 参数：主键的值 123456789101112131415let routerDBRequest &#x3D; window.indexedDB.open(&#39;dataAnalysis&#39;)routerDBRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123; db &#x3D; event.target.result let trans &#x3D; db.transaction([&#39;allRouteData&#39;]) let objectStores &#x3D; trans.objectStore(&#39;allRouteData&#39;) let request &#x3D; objectStores.get(1) request.onsuccess &#x3D; (event) &#x3D;&gt; &#123; if(event.target.result) &#123; &#125; const newRoute &#x3D; [] newRoute.push(event.target.result) &#125;&#125; 批量读取数据12345678910111213objectStores.openCursor().onsuccess &#x3D; (event) &#x3D;&gt; &#123; let res &#x3D; event.target.result if(res) &#123; let val &#x3D; res.value newRoute.push(val) store.dispatch(&#39;dealRouter&#x2F;SaveAllRouter&#39;, newRoute) router.push(&#123; path: newRoute[0].path &#125;) res.continue() &#125; else &#123; console.log(&#39;完成索引&#39;) &#125;&#125; 修改数据objectStore.put(item) 参数：一列数据 123456789101112let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;)const newRoute &#x3D; []objectStores.put(&#123;id: 1, name: &#39;首页&#39;, component: &#39;Layout&#39;, path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;dashboard&#39;, meta:&#39;&#123;&quot;title&quot;:&quot;首页&quot;&#125;&#39;, children: [&#123; name: &#39;首页&#39;, path: &#39;dashboard&#39;, component: &#39;Dashboard&#39;, id: 2, meta:&#39;&#123;&quot;title&quot;:&quot;首页&quot;&#125;&#39;&#125;]&#125;) 删除数据objectStore.del(num) 参数：删除的条数 12345let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;).del(1)request.onsuccess &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;数据删除成功&#39;)&#125; 使用索引索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。 12objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;) 完整测试案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788let routerDBRequest &#x3D; window.indexedDB.open(&#39;dataAnalysis&#39;)&lt;!-- error 表示数据库打开失败 --&gt;routerDBRequest.onerror &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;打开失败&#39;) console.log(event)&#125;&lt;!-- success 表示数据库打开成功 --&gt;routerDBRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;打开成功&#39;) &lt;!-- 读取单条数据 --&gt; db &#x3D; event.target.result let trans &#x3D; db.transaction([&#39;allRouteData&#39;]) let objectStores &#x3D; trans.objectStore(&#39;allRouteData&#39;) let request &#x3D; objectStores.get(1) &#x2F;&#x2F; get参数为主键的值 request.onsuccess &#x3D; (event) &#x3D;&gt; &#123; const newRoute &#x3D; [] newRoute.push(event.target.result) store.dispatch(&#39;dealRouter&#x2F;SaveAllRouter&#39;, newRoute) router.push(&#123; path: newRoute[0].path &#125;) &#125; &lt;!-- 批量读取数据 --&gt; objectStores.openCursor().onsuccess &#x3D; (event) &#x3D;&gt; &#123; let res &#x3D; event.target.result if(res) &#123; let val &#x3D; res.value newRoute.push(val) store.dispatch(&#39;dealRouter&#x2F;SaveAllRouter&#39;, newRoute) router.push(&#123; path: newRoute[0].path &#125;) res.continue() &#125; else &#123; console.log(&#39;完成索引&#39;) &#125; &#125; &lt;!-- 修改数据 --&gt; let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;) const newRoute &#x3D; [] objectStores.put(&#123;id: 1, name: &#39;首页&#39;, component: &#39;Layout&#39;, path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;dashboard&#39;, meta:&#39;&#123;&quot;title&quot;:&quot;首页&quot;&#125;&#39;, children: [&#123; name: &#39;首页&#39;, path: &#39;dashboard&#39;, component: &#39;Dashboard&#39;, id: 2, meta:&#39;&#123;&quot;title&quot;:&quot;首页&quot;&#125;&#39; &#125;]&#125;) &lt;!-- 删除数据 --&gt; let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;).del(1) request.onsuccess &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;数据删除成功&#39;) &#125;&#125;&#125;&lt;!-- upgradeneeded 数据库升级事件（指定版本大于数据库实际版本时触发） --&gt;routerDBRequest.onupgradeneeded &#x3D; (event) &#x3D;&gt; &#123; let db &#x3D; event.target.result &lt;!-- 创建数据仓库&#x2F;新建表 --&gt; &lt;!-- allRouteData为表名,keyPath为主键,使用autoIncrement可以自动生成主键 --&gt; if(!db.objectStoreNames.contains(&quot;allRouteData&quot;)) &#123; let allRoute &#x3D; this.db.createObjectStore(&quot;allRouteData&quot;, &#123; keyPath: &#39;id&#39;&#125;) &lt;!-- IDBObject.createIndex()是新建索引的方法， 三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值） --&gt; allRoute.createIndex(&#39;id&#39;, &#39;id&#39;, &#123; unique: true &#125;) allRoute.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;) allRoute.createIndex(&#39;path&#39;, &#39;path&#39;, &#123; unique: false &#125;) allRoute.createIndex(&#39;component&#39;, &#39;component&#39;, &#123; unique: false &#125;) allRoute.createIndex(&#39;hiddenInMenu&#39;, &#39;hiddenInMenu&#39;, &#123; unique: false&#125;) allRoute.createIndex(&#39;redirect&#39;, &#39;redirect&#39;, &#123;unique: false&#125;) allRoute.createIndex(&#39;meta&#39;, &#39;meta&#39;, &#123; unique: false&#125;) &#125; &lt;!-- 写入数据 --&gt; var objectStore &#x3D; transaction.objectStore(&quot;allRouteData&quot;) let addReq &#x3D; objectStore.add($&#123;data&#125;) addReq.onsuccess &#x3D; (event)&#x3D;&gt; &#123; console.log(&#39;数据写入成功&#39;) &#125; addReq.onerror &#x3D; (event) &#x3D;&gt; &#123; console.log(&#39;数据写入失败&#39;) &#125; &lt;!-- 利用索引检索数据 --&gt; let objectStores &#x3D; db.transaction([&#39;allRouteData&#39;], &#39;readwrite&#39;).objectStore(&#39;allRouteData&#39;) let index &#x3D; objectStores.index(&quot;name&quot;) index.get(&#39;首页&#39;).onsuccess &#x3D; (event)&#x3D;&gt; &#123; console.log(event.target.result) &#125;","categories":[{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/tags/web/"}]}],"categories":[{"name":"image","slug":"image","permalink":"https://lizeyu66.github.io/categories/image/"},{"name":"javascript","slug":"javascript","permalink":"https://lizeyu66.github.io/categories/javascript/"},{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lizeyu66.github.io/tags/hexo/"},{"name":"image","slug":"image","permalink":"https://lizeyu66.github.io/tags/image/"},{"name":"javascript","slug":"javascript","permalink":"https://lizeyu66.github.io/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://lizeyu66.github.io/tags/web/"}]}